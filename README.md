**Вариант 4**. Реализуйте рекурсивную функцию для переворота строки.

**Рекурсия для переворота строк на Python**:

**Базовый случай рекурсии (if len(s) <= 1)**:

Проверяется длина строки s.

Если строка пуста (len(s) == 0) или состоит из одного символа (len(s) == 1), функция возвращает её как есть.

Это условие останавливает рекурсию — без него функция вызывала бы себя бесконечно.

**Пример использования**:

Ввод:

text = "Hello World"

print(reverse_string(text)) 

**Вывод консоли**: dlroW olleH


**Временная сложность**: O(n^2)

**Почему O(n^2)**: 

1) **Глубина рекурсии**:

Функция вызывается n раз (по одному на каждый символ строки).

Глубина рекурсивного стека: O(n).

2) **Стоимость операций на каждом шаге**:

Срез s[1:] создаёт новую строку, копируя все символы кроме первого.

Для строки длины k операция среза занимает O(k) времени.

**На первом шаге срез для строки длины n**: O(n).

**На втором шаге срез для строки длины n−1**: O(n−1).

**Рекурсия для переворота строк на Java**:

1) **Класс и метод reverseString**:
   
**public class StringReverser** — объявление публичного класса с именем StringReverser.

**public static String reverseString(String s)** — публичный статический метод, принимающий строку s и возвращающий строку (обращённую).

**if (s.length() <= 1)** — условие базового случая рекурсии:

если длина строки ≤ 1 (пустая строка или один символ), возвращаем её как есть — она уже «обращена».

**return reverseString(s.substring(1)) + s.charAt(0) — рекурсивный вызов**:

**s.substring(1)** — подстрока от 1‑го символа до конца (т. е. вся строка без первого символа);

**reverseString(s.substring(Newton))** — рекурсивно обращаем эту подстроку;

**s.charAt(0)** — первый символ исходной строки;

складываем результат рекурсивного обращения подстроки и первый символ — так первый символ оказывается в конце, а остальная часть уже обращена.

2) **Метод main**:

Создаётся строка text = "Hello World".

Вызывается reverseString(text), результат выводится на консоль: "dlroW olleH".

**Временная сложность**: O(n^2)

**Почему O(n^2)**:

**Глубина рекурсии** — n вызовов (по одному на каждый символ, пока не дойдём до базового случая).

**Стоимость каждого вызова**:

**s.substring(1)** — создаёт новую строку, копируя n−1 символов. В Java строки неизменяемы, поэтому подстрока всегда копируется.

**s.charAt(0) — O(1)**.

Конкатенация ...+... — создаёт новую строку, копируя все символы из левой и правой части. В худшем случае это O(n) на каждый вызов

**Рекурсия для переворота строк на С++**:

1) **Директивы и пространство имён**:

**#include <iostream>** — подключает библиотеку для ввода‑вывода (используется cout).

**#include <string>** — подключает библиотеку для работы со строками типа std::string.

**using namespace std** — позволяет использовать имена из пространства имён std без префикса std:: (например, string вместо std::string).

**Функция reverse_string**:  рекурсивно обращает строку s.

**Базовый случай рекурсии**:






